importÂ requests
importÂ pandasÂ asÂ pd
fromÂ web3Â importÂ Web3
importÂ networkxÂ asÂ nx

#Â ===Â CONFIGÂ ===
INFURA_KEYÂ =Â '74eb8844b0934454*******ad74e3d55'
ETHERSCAN_KEY_ETHÂ =Â 'Q7QWJW*******J53GVFG8A1N9IP21PFBMN'
ETHERSCAN_KEY_ARBÂ =Â '21IVRQNWYKGTGUK89USN*******MNPJB6R'
ETHERSCAN_KEY_OPTÂ =Â '357GWKAF56******6P7HVS*******P13K'
BITQUERY_KEYÂ =Â 'ory_at_aor3ImP3aNR******j-lamuIUak8ebSG7dGt2O4m5Y.chGTywCn6zOOdi1oeaYh7Px0ytjTcVHAF4qy3YpMwD0'
COVALENT_KEYÂ =Â 'cqt_rQPCFPHGfmptPhy*******8PF9gbP'Â Â #Â EmptyÂ meansÂ weâ€™llÂ useÂ freeÂ endpoints

SEEDÂ =Â '0x76135D845cc090530845a0*******9C772F21303'
MAX_HOPSÂ =Â 2Â Â #Â adjustÂ forÂ safety

STATIC_CEXÂ =Â [
Â Â Â Â "0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be",
Â Â Â Â "0x28c6c06298d514db089934071355e5743bf21d60",
Â Â Â Â "0x742d35cc6634c0532925a3b844bc454e4438f44",
Â Â Â Â "0x564286362092d8e7936f0549571a803b203aaced"
]
STATIC_CEXÂ =Â [a.lower()Â forÂ aÂ inÂ STATIC_CEX]

w3Â =Â Web3(Web3.HTTPProvider(f'https://mainnet.infura.io/v3/{INFURA_KEY}'))
print(f"LoadedÂ {len(STATIC_CEX)}Â staticÂ CEXÂ âœ…")

#Â ===Â CLASSIFYÂ ===
defÂ classify(address):
Â Â Â Â addressÂ =Â address.lower()
Â Â Â Â ifÂ addressÂ inÂ STATIC_CEX:
Â Â Â Â Â Â Â Â returnÂ 'StaticÂ CEX'
Â Â Â Â try:
Â Â Â Â Â Â Â Â codeÂ =Â w3.eth.get_code(Web3.to_checksum_address(address))
Â Â Â Â Â Â Â Â ifÂ codeÂ !=Â b'':
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ 'Contract'
Â Â Â Â except:
Â Â Â Â Â Â Â Â pass
Â Â Â Â urlÂ =Â f"https://api.etherscan.io/api?module=account&action=txlist&address={address}&apikey={ETHERSCAN_KEY_ETH}"
Â Â Â Â txsÂ =Â requests.get(url).json().get('result',Â [])
Â Â Â Â ifÂ len(txs)Â >=Â 5000:
Â Â Â Â Â Â Â Â returnÂ 'LikelyÂ HotÂ Wallet'
Â Â Â Â returnÂ 'EOA'

#Â ===Â GRAPHÂ BUILDÂ ===
edgesÂ =Â []
seenÂ =Â set()

defÂ crawl_etherscan(chain,Â key,Â base_url):
Â Â Â Â queueÂ =Â [(SEED.lower(),Â 0)]
Â Â Â Â whileÂ queue:
Â Â Â Â Â Â Â Â current,Â depthÂ =Â queue.pop(0)
Â Â Â Â Â Â Â Â ifÂ currentÂ inÂ seenÂ orÂ depthÂ >Â MAX_HOPS:
Â Â Â Â Â Â Â Â Â Â Â Â continue
Â Â Â Â Â Â Â Â seen.add(current)
Â Â Â Â Â Â Â Â print(f"ğŸ”Â CrawlingÂ {chain}Â Etherscan:Â {current}Â |Â DepthÂ {depth}")
Â Â Â Â Â Â Â Â urlÂ =Â f"{base_url}?module=account&action=txlist&address={current}&apikey={key}"
Â Â Â Â Â Â Â Â txsÂ =Â requests.get(url).json().get('result',Â [])
Â Â Â Â Â Â Â Â forÂ txÂ inÂ txs[:5]:
Â Â Â Â Â Â Â Â Â Â Â Â fÂ =Â tx['from'].lower()
Â Â Â Â Â Â Â Â Â Â Â Â tÂ =Â tx['to'].lower()Â ifÂ tx['to']Â elseÂ ''
Â Â Â Â Â Â Â Â Â Â Â Â vÂ =Â int(tx['value'])Â /Â 1e18
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ vÂ ==Â 0Â orÂ notÂ t:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â continue
Â Â Â Â Â Â Â Â Â Â Â Â edges.append((f,Â t,Â v,Â chain))
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ tÂ notÂ inÂ seen:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â queue.append((t,Â depthÂ +Â 1))

#Â ===Â MAINÂ ETHERSCANÂ TRACESÂ ===
crawl_etherscan('ethereum',Â ETHERSCAN_KEY_ETH,Â 'https://api.etherscan.io/api')
crawl_etherscan('arbitrum',Â ETHERSCAN_KEY_ARB,Â 'https://api.arbiscan.io/api')
crawl_etherscan('optimism',Â ETHERSCAN_KEY_OPT,Â 'https://api-optimistic.etherscan.io/api')

#Â ===Â BITQUERYÂ ERC-20Â ===
bitquery_urlÂ =Â 'https://streaming.bitquery.io/graphql'
queryÂ =Â {
Â Â "query":Â """
Â Â Â Â queryÂ ($address:Â String!)Â {
Â Â Â Â Â Â EVM(dataset:Â combined,Â network:Â eth)Â {
Â Â Â Â Â Â Â Â Transfers(
Â Â Â Â Â Â Â Â Â Â where:Â {
Â Â Â Â Â Â Â Â Â Â Â Â any:Â [
Â Â Â Â Â Â Â Â Â Â Â Â Â Â {Transfer:Â {Sender:Â {is:Â $address}}},
Â Â Â Â Â Â Â Â Â Â Â Â Â Â {Transfer:Â {Receiver:Â {is:Â $address}}}
Â Â Â Â Â Â Â Â Â Â Â Â ],
Â Â Â Â Â Â Â Â Â Â Â Â Transfer:Â {Currency:Â {Native:Â false,Â Fungible:Â true},Â Amount:Â {gt:Â "0"}}
Â Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â Â Â limit:Â {count:Â 5}
Â Â Â Â Â Â Â Â )Â {
Â Â Â Â Â Â Â Â Â Â TransferÂ {
Â Â Â Â Â Â Â Â Â Â Â Â Sender
Â Â Â Â Â Â Â Â Â Â Â Â Receiver
Â Â Â Â Â Â Â Â Â Â Â Â Amount
Â Â Â Â Â Â Â Â Â Â Â Â CurrencyÂ {Â SymbolÂ }
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â Â Â }
Â Â """,
Â Â "variables":Â {"address":Â SEED}
}
headersÂ =Â {
Â Â 'Authorization':Â f'BearerÂ {BITQUERY_KEY}',
Â Â 'Content-Type':Â 'application/json'
}
respÂ =Â requests.post(bitquery_url,Â json=query,Â headers=headers)
print(f"BitqueryÂ ERC-20Â ethÂ status:Â {resp.status_code}")

bitquery_okÂ =Â False
ifÂ resp.ok:
Â Â Â Â transfersÂ =Â resp.json()['data']['EVM']['Transfers']
Â Â Â Â ifÂ transfers:
Â Â Â Â Â Â Â Â bitquery_okÂ =Â True
Â Â Â Â Â Â Â Â forÂ txÂ inÂ transfers:
Â Â Â Â Â Â Â Â Â Â Â Â fÂ =Â tx['Transfer']['Sender'].lower()
Â Â Â Â Â Â Â Â Â Â Â Â tÂ =Â tx['Transfer']['Receiver'].lower()
Â Â Â Â Â Â Â Â Â Â Â Â vÂ =Â float(tx['Transfer']['Amount'])
Â Â Â Â Â Â Â Â Â Â Â Â edges.append((f,Â t,Â v,Â 'ethereum'))
Â Â Â Â else:
Â Â Â Â Â Â Â Â print("âš ï¸Â NoÂ BitqueryÂ ERC-20Â transfersÂ found.")

#Â ===Â COVALENTÂ FALLBACKÂ ===
ifÂ notÂ bitquery_ok:
Â Â Â Â print("ğŸ”Â UsingÂ CovalentÂ fallback...")
Â Â Â Â forÂ chain,Â chain_idÂ inÂ [('ethereum',Â 1),Â ('arbitrum',Â 42161),Â ('optimism',Â 10)]:
Â Â Â Â Â Â Â Â urlÂ =Â f"https://api.covalenthq.com/v1/{chain_id}/address/{SEED}/transactions_v3/?key={COVALENT_KEY}"
Â Â Â Â Â Â Â Â respÂ =Â requests.get(url)
Â Â Â Â Â Â Â Â print(f"CovalentÂ {chain}Â status:Â {resp.status_code}")
Â Â Â Â Â Â Â Â ifÂ resp.ok:
Â Â Â Â Â Â Â Â Â Â Â Â itemsÂ =Â resp.json()['data']['items']
Â Â Â Â Â Â Â Â Â Â Â Â forÂ txÂ inÂ items[:5]:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fÂ =Â tx['from_address'].lower()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tÂ =Â tx['to_address'].lower()Â ifÂ tx['to_address']Â elseÂ ''
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â vÂ =Â int(tx['value'])Â /Â 1e18Â ifÂ tx['value']Â elseÂ 0
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ vÂ ==Â 0Â orÂ notÂ t:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â continue
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â edges.append((f,Â t,Â v,Â chain))

#Â ===Â SAVEÂ ===
dfÂ =Â pd.DataFrame(edges,Â columns=['from',Â 'to',Â 'value',Â 'chain'])
df.to_csv('trace_combined.csv',Â index=False)
print("âœ…Â SavedÂ trace_combined.csvÂ withÂ chainÂ column")

addressesÂ =Â pd.unique(df[['from',Â 'to']].values.ravel())
resultsÂ =Â []
forÂ addrÂ inÂ addresses:
Â Â Â Â results.append({'address':Â addr,Â 'class':Â classify(addr)})
df_nodesÂ =Â pd.DataFrame(results)
df_nodes.to_csv('classified_nodes.csv',Â index=False)
print("âœ…Â SavedÂ classified_nodes.csvÂ withÂ walletÂ classes")

GÂ =Â nx.from_pandas_edgelist(df,Â 'from',Â 'to',Â edge_attr=['value',Â 'chain'])
nx.write_gexf(G,Â 'trace_graph.gexf')
print("âœ…Â SavedÂ trace_graph.gexfÂ forÂ GephiÂ Lite")
